# -*- coding: utf-8 -*-
"""Orientation Tracking Test Set.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17JU1LRUqvV5YIpUV_oVmfmEF5bTYmnqd
"""

pip install transforms3d

import pickle
import sys
import time
import numpy as np
import transforms3d.euler as euler
from pprint import pprint
import transforms3d.quaternions as quaternions
import matplotlib.pyplot as plt
import jax
import jax.numpy as jnp
import jax.numpy as np
import jaxlib

# fuction to strat time
def tic():
    return time.time()

#function to define Total time taken to load the data
def toc(tstart, nm=""):
  	print('%s took: %s sec.\n' % (nm,(time.time() - tstart)))

#Function to read the data from the pickle file
def read_data(fname):
    d = []
    with open(fname, 'rb') as f:
        if sys.version_info[0] < 3:
            d = pickle.load(f)
        else:
            d = pickle.load(f, encoding='latin1')  # needed for python 3

    return d

# Convert from raw acceleration values to physical units
def convert_raw_acceleration(imu_array):
    Vref = 3300

    ax_array = (imu_array[0, :]).astype(float)
    ay_array = (imu_array[1, :]).astype(float)
    az_array = (imu_array[2, :]).astype(float)

    sensitivity_a = 330
    scale_factor_a = Vref/1023/sensitivity_a

    ax = ((ax_array -jnp.mean(ax_array[:50]) + 0.05) * scale_factor_a)*9.81
    ay = ((ay_array -jnp.mean(ay_array[:50]) + 0.05) * scale_factor_a)*9.81
    az = ((az_array - (jnp.mean(az_array[:50] + 0.05) - (1/scale_factor_a))) * scale_factor_a)*(-9.81)

    return np.vstack((ax, ay, az)).T

# Convert from raw angular velocity values to physical units
def convert_raw_angular_velocity(imu_array):
    Vref = 3300

    wz_array = (imu_array[3, :]).astype(float)
    wx_array = (imu_array[4, :]).astype(float)
    wy_array = (imu_array[5, :]).astype(float)

    sensitivity_w = 3.33
    scale_factor_w = Vref/1023/sensitivity_w*(np.pi/180)

    wz = (wz_array -jnp.mean(wz_array[:50]) + 0.05) * scale_factor_w
    wx = (wx_array -jnp.mean(wx_array[:50]) + 0.05) * scale_factor_w
    wy = (wy_array -jnp.mean(wy_array[:50]) + 0.05) * scale_factor_w

    return np.column_stack((wx, wy, wz))

def calculate_timestamps(abs_timestamps):
    # Ensure the input array is not empty
    if len(abs_timestamps) == 0:
        return []

    inc_timestamps = abs_timestamps - abs_timestamps[0]

    return inc_timestamps

# file path location

from google.colab import drive
drive.mount('/content/drive')

dataset="10"

ifile = "/content/drive/MyDrive/data/testset/imu/imuRaw" + dataset + ".p"

ts = tic()
imud = read_data(ifile)
toc(ts,"Data import")

# # printing the data to check for key: value pairs
# pprint(imud)

# Variable containing the dictionary

imu_array = imud['vals']
imu_ts_array = imud['ts']

def quaternion_multiply(q1, q2):
    w1, x1, y1, z1 = q1
    w2, x2, y2, z2 = q2

    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2
    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2
    y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2
    z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2

    return jnp.array([w, x, y, z])

def quaternion_exponential(qv):

    # Normalize the axis vector
    axis_norm = np.linalg.norm(qv) + 1e-6
    axis = qv / axis_norm

    # Calculate quaternion exponential
    quat_exp = np.array(np.array([np.cos(axis_norm), np.sin(axis_norm) * axis[0], np.sin(axis_norm) * axis[1], np.sin(axis_norm) * axis[2]]))

    return quat_exp

def quaternion_log(q):
    # Ensure the quaternion is normalized
    q_norm = jnp.linalg.norm(q) + 1e-6
    q_normalized = q / q_norm

    # Extract scalar and vector parts
    s, v = q[0], q[1:]

    # Calculate quaternion logarithm
    norm_v = jnp.linalg.norm(v) + 1e-6
    log_s = jnp.log(q_norm + 1e-6)
    log_v = (v / norm_v) * jnp.arccos(s / q_norm)

    # Construct the quaternion logarithm
    log_q = jnp.concatenate((jnp.array([log_s]), log_v))

    return log_q

def quaternion_inverse(q):
    # Ensure the quaternion is normalized
    q_norm = jnp.linalg.norm(q) + 1e-6
    q_normalized = q / q_norm

    # Calculate the quaternion conjugate
    conjugate_q = jnp.concatenate((jnp.array([q_normalized[0]]), jnp.array(-q_normalized[1:])))

    # Calculate the quaternion inverse
    inverse_q = conjugate_q / (q_norm)

    return inverse_q

def motion_model(omega_array, timestamps, q_1):
    # initialiaze the quaternion
    q_list = q_1

    for i in range(1, len(timestamps)):

        tau = timestamps[i] - timestamps[i-1]
        omega = omega_array[:, i-1]

        # calculate next quaternion
        qt = q_list[-1]
        axis = tau*omega/2.0

        q_exp = quaternion_exponential(axis)
        qt_next = quaternion_multiply(qt,q_exp)

        q_list.append(qt_next)

    return q_list

def quaternion_exp_tau_omega(omega_array, timestamps):
    q_exp_tau_omega_initial = jnp.array([[1.0, 0.0, 0.0, 0.0]])
    tau = timestamps[1:] - timestamps[:-1]
    axis = omega_array[:-1] * tau / 2.0

    print(axis)
    q_exp_tau_omega = jax.vmap(quaternion_exponential)(axis)

    return jnp.vstack((q_exp_tau_omega_initial, q_exp_tau_omega))

# define observation model
def observation_model(q_list):
    observed_acceleration = []
    g = 9.81
    g_quaternion = np.tile(np.array([[0, 0, 0, -g]]), (q_list.shape[0], 1))

    qt_inv = jax.vmap(quaternion_inverse)(q_list)
    q1 = jax.vmap(quaternion_multiply)(g_quaternion, q_list)
    observed_acceleration = jax.vmap(quaternion_multiply)(qt_inv, q1)

    return observed_acceleration

# Now, timestamps will contain the incremental values
timestamps_imu = np.array(calculate_timestamps(imu_ts_array.flatten())).reshape(-1, 1)
print(timestamps_imu.shape)

# calibrated imu data array
accel_array = convert_raw_acceleration(imu_array)
accel_array = jnp.array(accel_array)
print(accel_array.shape)

# calculate Quaternions
omega_array = convert_raw_angular_velocity(imu_array)
q_1 = [np.array([1.0, 0.0, 0.0, 0.0])]
q_list = motion_model(omega_array, imu_ts_array.flatten(), q_1)
q_array = jnp.array(q_list)
print(q_array.shape)

# Call the function with the entire array of quaternions
observed_acceleration = jnp.array(observation_model(q_array))
print(observed_acceleration.shape)

@jax.jit
def cost_function(q_array, accel_array, omega_array, timestamps_imu):
    # Initialize cost
    cost = 0.0

    #motion model
    q_exp_tau_omega = jnp.array(quaternion_exp_tau_omega(omega_array,timestamps_imu))
    q_array_mm = jax.vmap(quaternion_multiply)(q_array, q_exp_tau_omega)

    # Motion model error term
    q_array_inv = jax.vmap(quaternion_inverse)(q_array)
    q_array_inv = q_array_inv[1:,:]
    q_array_mm = q_array_mm[:-1,:]


    relative_rotation = jax.vmap(quaternion_multiply)(q_array_inv, q_array_mm)
    relative_rotation_log = jax.vmap(quaternion_log)(relative_rotation + 1e-6)
    error_motion_model = jnp.linalg.norm(2.0 * relative_rotation_log, axis = 1) ** 2

    cost = cost + 0.5 * jnp.sum(error_motion_model)

    # observation model
    observed_acceleration = jnp.array(observation_model(q_array))
    accel_array = jnp.hstack((jnp.zeros((accel_array.shape[0], 1)), accel_array))

    # Observation model error term
    observed_acceleration = observed_acceleration[1:,:]
    accel_array = accel_array[1:,:]
    observed_err = accel_array - observed_acceleration
    error_observation_model = jnp.linalg.norm(observed_err, axis = 1) ** 2

    #total cost
    cost = cost + 0.5 * jnp.sum(error_observation_model)


    return cost

learning_rate = 0.001
q_optimized = q_array
placeholder = 1e-6
iteration = []
cost_opt = []

for i in range(40):
    grad_cost = jax.grad(cost_function)(q_optimized, accel_array, omega_array, timestamps_imu)
    grad_cost_function = jnp.where(jnp.isnan(grad_cost), placeholder, grad_cost)

    # optimization
    q_optimized = q_optimized - learning_rate * grad_cost

    # Optmization constraints
    norms = jnp.linalg.norm(q_optimized, axis=1, keepdims=True) + 1e-6
    q_optimized = q_optimized / norms

    # store arguments to plot the cost function
    iteration.append(i)
    cost = cost_function(q_optimized, accel_array, omega_array, timestamps_imu)
    cost_opt.append(cost)

    print("iteration: ", i)

# plot starts here

def quaternion_to_euler(q):
    # Convert quaternion to Euler angles (roll, pitch, yaw)
    return euler.quat2euler(q, axes='sxyz')

def rotation_matrix_to_euler(rot_matrix):
    # Convert rotation matrix to Euler angles (roll, pitch, yaw)
    return euler.mat2euler(rot_matrix, axes='sxyz')

# Convert quaternion to Euler angles
imu_euler_angles_opt = np.array([quaternion_to_euler(q) for q in q_optimized])

# Convert angles to degrees
imu_euler_angles_opt_degrees = np.degrees(imu_euler_angles_opt)

# Plot Euler angles
plt.figure(figsize=(15, 6))

# Plot Roll
plt.subplot(3, 1, 1)
plt.plot(timestamps_imu, imu_euler_angles_opt_degrees[:, 0], label='Optimized Roll', color='orange')
plt.title('Roll Angle')
plt.xlabel('Timestamps (s)')
plt.ylabel('Angle (degrees)')
plt.legend()

# Plot Pitch
plt.subplot(3, 1, 2)
plt.plot(timestamps_imu, imu_euler_angles_opt_degrees[:, 1], label='Optimized Pitch', color='orange')
plt.title('Pitch Angle')
plt.xlabel('Timestamps (s)')
plt.ylabel('Angle (degrees)')
plt.legend()

# Plot Yaw
plt.subplot(3, 1, 3)
plt.plot(timestamps_imu, imu_euler_angles_opt_degrees[:, 2], label='Optimized Yaw', color='orange')
plt.title('Yaw Angle')
plt.xlabel('Timestamps (s)')
plt.ylabel('Angle (degrees)')
plt.legend()

plt.tight_layout()
plt.show()

# Plot Euler angles
plt.figure(figsize=(15, 6))

# Plot optmization vs iteration
plt.plot(iteration, cost_opt, label='Cost', color='pink')
plt.title('Cost vs Iteration')
plt.xlabel('Iteration')
plt.ylabel('Cost')
plt.legend()

plt.tight_layout()
plt.show()